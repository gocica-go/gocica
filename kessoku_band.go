// Code generated by kessoku. DO NOT EDIT.

package main

import (
	"context"
	"github.com/mazrean/gocica/internal"
	"github.com/mazrean/gocica/internal/backend"
	"github.com/mazrean/gocica/internal/backend/blob"
	"github.com/mazrean/gocica/log"
	"github.com/mazrean/gocica/protocol"
	"github.com/mazrean/kessoku"
	"golang.org/x/sync/errgroup"
)

func InitializeProcess(ctx context.Context, logger log.Logger, dir Dir, token Token, cacheURL CacheURL, runnerOS RunnerOS, ref Ref, sha Sha) (*protocol.Process, error) {
	var (
		disk                 *backend.Disk
		diskCh               = make(chan struct{})
		gitHubCacheClient    *blob.GitHubCacheClient
		gitHubCacheClientCh  = make(chan struct{})
		uploadClient         blob.UploadClient
		downloadClient       blob.DownloadClient
		downloader           *blob.Downloader
		downloaderCh         = make(chan struct{})
		uploader             *blob.Uploader
		uploaderCh           = make(chan struct{})
		gitHubActionsCache   *backend.GitHubActionsCache
		gitHubActionsCacheCh = make(chan struct{})
		conbinedBackend      *backend.ConbinedBackend
		gocica               *internal.Gocica
		process              *protocol.Process
	)
	eg, ctx := errgroup.WithContext(ctx)
	eg.Go(func() error {
		var err error
		gitHubCacheClient, err = kessoku.Async(kessoku.Provide(NewGitHubCacheClientWithDI)).Fn()(ctx, logger, token, cacheURL, runnerOS, ref, sha)
		if err != nil {
			return err
		}
		close(gitHubCacheClientCh)
		var err0 error
		uploadClient, err0 = kessoku.Async(kessoku.Provide(blob.NewUploadClient)).Fn()(ctx, gitHubCacheClient)
		if err0 != nil {
			return err0
		}
		select {
		case <-downloaderCh:
		case <-ctx.Done():
			return ctx.Err()
		}
		uploader = kessoku.Provide(blob.NewUploaderOrNil).Fn()(ctx, logger, uploadClient, downloader)
		close(uploaderCh)
		return nil
	})
	eg.Go(func() error {
		select {
		case <-gitHubCacheClientCh:
		case <-ctx.Done():
			return ctx.Err()
		}
		var err1 error
		downloadClient, err1 = kessoku.Async(kessoku.Provide(blob.NewDownloadClient)).Fn()(ctx, gitHubCacheClient)
		if err1 != nil {
			return err1
		}
		var err2 error
		downloader, err2 = kessoku.Async(kessoku.Provide(blob.NewDownloader)).Fn()(ctx, logger, downloadClient)
		if err2 != nil {
			return err2
		}
		close(downloaderCh)
		return nil
	})
	eg.Go(func() error {
		for _, ch := range []<-chan struct{}{gitHubCacheClientCh, diskCh, uploaderCh, downloaderCh} {
			select {
			case <-ch:
			case <-ctx.Done():
				return ctx.Err()
			}
		}
		var err3 error
		gitHubActionsCache, err3 = kessoku.Async(kessoku.Bind[backend.RemoteBackend](kessoku.Provide(backend.NewGitHubActionsCache))).Fn()(ctx, logger, gitHubCacheClient, disk, uploader, downloader)
		if err3 != nil {
			return err3
		}
		close(gitHubActionsCacheCh)
		return nil
	})
	eg.Go(func() error {
		for _, ch := range []<-chan struct{}{diskCh, gitHubActionsCacheCh} {
			select {
			case <-ch:
			case <-ctx.Done():
				return ctx.Err()
			}
		}
		var err4 error
		conbinedBackend, err4 = kessoku.Async(kessoku.Bind[backend.Backend](kessoku.Provide(backend.NewConbinedBackend))).Fn()(logger, disk, gitHubActionsCache)
		if err4 != nil {
			return err4
		}
		gocica = kessoku.Provide(internal.NewGocica).Fn()(logger, conbinedBackend)
		process = kessoku.Provide(NewProcessWithOptions).Fn()(logger, gocica)
		return nil
	})
	var err5 error
	disk, err5 = kessoku.Async(kessoku.Bind[backend.LocalBackend](kessoku.Provide(NewDiskWithDI))).Fn()(logger, dir)
	if err5 != nil {
		var zero *protocol.Process
		return zero, err5
	}
	close(diskCh)
	if err := eg.Wait(); err != nil {
		return nil, err
	}
	return process, nil
}
