# Implementation Plan: Kessoku DI Integration

**Branch**: `001-kessoku-di` | **Date**: 2025-12-27 | **Spec**: [spec.md](spec.md)
**Input**: Feature specification from `/specs/001-kessoku-di/spec.md`

## Summary

Replace manual component initialization in GoCICa with kessoku DI framework to provide:
- Clear dependency declarations with compile-time validation
- Parallel initialization of independent components (Disk + GitHub Actions Cache client setup)
- Interface-based dependency injection for improved testability
- Type-safe code generation via `go generate`

## Technical Context

**Language/Version**: Go 1.24+
**Primary Dependencies**:
- `github.com/mazrean/kessoku` (DI framework)
- `github.com/alecthomas/kong` (CLI parsing - outside DI)
- `golang.org/x/sync/errgroup` (auto-generated by kessoku for async)

**Storage**: Local disk cache + GitHub Actions Cache (Azure Blob Storage)
**Testing**: `go test` with race detection
**Target Platform**: Linux (CI runners), cross-platform CLI
**Project Type**: Single CLI application
**Performance Goals**: Startup time must not regress (+5% tolerance)
**Constraints**: Zero runtime DI overhead (compile-time code generation)
**Scale/Scope**: ~10 providers, ~7 interfaces to bind

## Functional Requirements Coverage

### FR-001: Use kessoku DI framework
**Implementation**: Replace `createBackend()` in main.go with kessoku-generated injector. All component initialization moves to `injector.go` using `kessoku.Inject`, `kessoku.Provide`, and related functions.

### FR-002: Define injector function signature
**Implementation**: Injector signature will be:
```go
func InitializeProcess(ctx context.Context) (*protocol.Process, error)
```
- `ctx` is the only parameter (required for async providers)
- Logger and config values are injected via `kessoku.Value` inside the injector declaration
- Returns `*protocol.Process` and `error`

### FR-003: Define providers for all major components
**Implementation**: The following providers will be defined:
| Component | Provider Function | Notes |
|-----------|------------------|-------|
| Logger | `kessoku.Value(logger)` | Injected from main, created based on CLI log level |
| Disk | `kessoku.Provide(backend.NewDisk)` | Implements LocalBackend (async) |
| blob.AzureUploadClient | `kessoku.Provide(blob.NewAzureUploadClient)` | Implements blob.UploadClient (async) |
| blob.AzureDownloadClient | `kessoku.Provide(blob.NewAzureDownloadClient)` | Implements blob.DownloadClient (async) |
| blob.Uploader | `kessoku.Provide(blob.NewUploader)` | Uses UploadClient |
| blob.Downloader | `kessoku.Provide(blob.NewDownloader)` | Uses DownloadClient |
| GitHubActionsCache | `kessoku.Provide(backend.NewGitHubActionsCache)` | Implements RemoteBackend |
| ConbinedBackend | `kessoku.Provide(backend.NewConbinedBackend)` | Implements Backend |
| Gocica | `kessoku.Provide(internal.NewGocica)` | Main application logic |
| Process | `kessoku.Provide(NewProcessWithOptions)` | Wrapper that creates ProcessOptions |

### FR-004: Use kessoku.Async for independent providers
**Implementation**:
```go
// Disk initialization (directory creation)
kessoku.Async(kessoku.Bind[backend.LocalBackend](kessoku.Provide(backend.NewDisk)))

// GitHub Actions Cache client setup (HTTP client, URL parsing)
kessoku.Async(kessoku.Bind[blob.UploadClient](kessoku.Provide(blob.NewAzureUploadClient)))
kessoku.Async(kessoku.Bind[blob.DownloadClient](kessoku.Provide(blob.NewAzureDownloadClient)))
```
**Parallel execution**: Disk, AzureUploadClient, and AzureDownloadClient all run in parallel (Pool 1) because:
- Disk only depends on logger and dir (values)
- AzureUploadClient only depends on token and cacheURL (values)
- AzureDownloadClient only depends on token and cacheURL (values)

**Sequential after Pool 1**: GitHubActionsCache depends on LocalBackend + Uploader + Downloader, so it runs after all async providers complete.

### FR-005: Handle and propagate errors from providers
**Implementation**:
- All providers that can fail return `(T, error)`
- kessoku generates `if err != nil { return nil, err }` after each call
- For async providers, errors are collected via errgroup and returned by `eg.Wait()`
- Injector returns error to caller (main.go)

### FR-006: Add go:generate directive
**Implementation**: In `injector.go`:
```go
//go:generate go tool github.com/mazrean/kessoku/cmd/kessoku $GOFILE
```

### FR-007: Maintain same runtime behavior
**Implementation**:
- Degraded mode: When injector returns error, main.go logs warning and continues without backend handlers (no-cache mode)
- Warning log on backend failure, not panic
- DevFlag profiling start/stop remains in main (outside DI scope)

```go
// In main.go
process, err := InitializeProcess(ctx)
if err != nil {
    logger.Warnf("failed to initialize: %v. no cache will be used.", err)
    process = protocol.NewProcess(protocol.WithLogger(logger))
}
```

### FR-008: Use kessoku.Bind for interfaces
**Implementation**: Interface bindings for test mocking:
```go
kessoku.Bind[backend.Backend](kessoku.Provide(backend.NewConbinedBackend))
kessoku.Bind[backend.LocalBackend](kessoku.Provide(backend.NewDisk))
kessoku.Bind[backend.RemoteBackend](kessoku.Provide(backend.NewGitHubActionsCache))
kessoku.Bind[blob.UploadClient](kessoku.Provide(blob.NewAzureUploadClient))
kessoku.Bind[blob.DownloadClient](kessoku.Provide(blob.NewAzureDownloadClient))
```
**Note**: blob.UploadClient and blob.DownloadClient are now exposed in the injector graph (not created internally by GitHubActionsCache) to satisfy FR-008 binding requirements.

### FR-009: Inject configuration values via kessoku.Value
**Implementation**: Individual values injected inside the injector declaration:
```go
var _ = kessoku.Inject[*protocol.Process](
    "InitializeProcess",
    kessoku.Value(logger),           // log.Logger
    kessoku.Value(CLI.LogLevel),     // string - log level
    kessoku.Value(CLI.Dir),          // string - cache directory
    kessoku.Value(CLI.Github.Token), // string - GitHub token
    kessoku.Value(CLI.Github.CacheURL),
    kessoku.Value(CLI.Github.RunnerOS),
    kessoku.Value(CLI.Github.Ref),
    kessoku.Value(CLI.Github.Sha),
    // ... providers ...
)
```

### FR-010: Commit generated files
**Implementation**: Generated `injector_band.go` files will be committed to the repository for reproducible builds. Add to version control, do NOT add to `.gitignore`.

### FR-011: Items outside DI scope
**Implementation**: The following remain manually managed in main.go:
- CLI parsing via Kong
- Default directory resolution (`os.UserCacheDir()`)
- Log level selection and logger creation based on CLI input
- DevFlag profiling (`StartProfiling`/`StopProfiling`)

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Constitution is in template state (not configured), so no specific gates apply. Proceeding with best practices:
- Maintain backward compatibility with existing behavior
- Keep changes minimal and focused on DI integration
- Preserve existing test coverage

## Project Structure

### Documentation (this feature)

```text
specs/001-kessoku-di/
├── plan.md              # This file
├── research.md          # Phase 0 output
├── data-model.md        # Phase 1 output
├── quickstart.md        # Phase 1 output
├── contracts/           # Phase 1 output (N/A - no API contracts)
└── tasks.md             # Phase 2 output (/speckit.tasks command)
```

### Source Code (repository root)

```text
.
├── main.go                           # Entry point (CLI parsing, logger creation)
├── injector.go                       # NEW: kessoku.Inject declarations
├── injector_band.go                  # GENERATED: Injector implementation (COMMITTED per FR-010)
├── internal/
│   ├── gocica.go                     # Gocica struct (unchanged)
│   ├── backend/
│   │   ├── backend.go                # Backend interfaces + ConbinedBackend
│   │   ├── disk.go                   # Disk implementation
│   │   ├── github_actions_cache.go   # GitHubActionsCache implementation (MODIFIED for DI)
│   │   └── blob/
│   │       ├── upload.go             # Uploader + UploadClient interface
│   │       ├── download.go           # Downloader + DownloadClient interface
│   │       └── azure_blob_storage.go # Azure implementations
│   ├── pkg/log/                      # Logger (injected via kessoku.Value)
│   └── proto/                        # Protobuf definitions
├── protocol/                         # GOCACHEPROG protocol
│   └── process.go                    # Process struct
└── tools/go.mod                      # Tool dependencies (add kessoku)
```

**Structure Decision**: Single project structure. New `injector.go` file will be created at repository root alongside `main.go` to contain all kessoku.Inject declarations. Generated `injector_band.go` will be committed to the repository per FR-010.

## Complexity Tracking

No violations identified. The implementation follows standard Go patterns:
- Single injector file for all DI declarations
- Interface binding follows existing interface definitions
- No new abstractions beyond what kessoku provides
